////////////////////////////////////////////////////////////
	// Constructor and Destructor                             //
	////////////////////////////////////////////////////////////
	Graph::Graph(const int maxSize) :
			maxSize(maxSize) {
		/* Init the matrix vector */
		matrix = (double**) malloc(maxSize * sizeof(double**));
		if (matrix == nullptr) {
			exit (EXIT_FAILURE);
		}
		for (int i = 0; i < maxSize; ++i) {
			matrix[i] = (double*) malloc(maxSize * sizeof(double*));
			if (matrix == nullptr) {
				exit (EXIT_FAILURE);
			}
		}
		/* set all edge values to 0 */
		clearEdges();

		/* Init the nodes vector */
		nodes.reserve(maxSize);
	}

	Graph::~Graph() {
		clearEdges();
		for (int i = 0; i < maxSize; i++) {
			free(matrix[i]);
			matrix[i] = nullptr;
		}

		free(matrix);
		matrix = nullptr;
	}
	////////////////////////////////////////////////////////////
	// Private methods                                        //
	////////////////////////////////////////////////////////////
	int Graph::getIdxForVertex(const Vertex* node) const {
		int idx = -1;

		if (!nodes.empty()) {
			idx = 0;
			while ((idx < nodes.size()) && (nodes[idx] != node)) {
				idx++;
			}
			idx = (idx == nodes.size()) ? -1 : idx;
		}

		return idx;
	}

	void Graph::deepTraverse(Vertex* node, vector<Vertex*>* visited) const {

		/* anchor for already visited */
		if ((find(visited->begin(), visited->end(), node) == visited->end())) {
			/* add to call stack */
			visited->push_back(node);
			/* get first connected vertex index */
			int colIdx = 0;
			int rowIdx = getIdxForVertex(node);
			for (int i = 0; i < nodes.size(); ++i) {
				/* visit next child */
				if (matrix[rowIdx][colIdx] != 0) {
					deepTraverse(nodes[colIdx], visited);
				}
			}
			cout << "Visited: " << node << endl << flush;
			/* else end of this recursive way because of recursion */
		} else {
			cout << "recursion aborted because of recursion" << endl << flush;
		}
	}

	void Graph::breathTraverse(Vertex* node, vector<Vertex*>* visited) const {

	}

	////////////////////////////////////////////////////////////
	// Public methods                                         //
	////////////////////////////////////////////////////////////
	void Graph::addVertex(Vertex* node) {
		/* Add if not already present */
		if (find(nodes.begin(), nodes.end(), node) != nodes.end()) {
			cout << "vertex already present !!! Adding aborted" << endl
					<< flush;
		} else {
			cout << "Vertex node added !!! node.name: " << node->name << endl;
			nodes.push_back(node);
		}
	}

	void Graph::addEdge(const Vertex* startNode, const Vertex* endNode,
			double weight) {
		int rowIdx, colIdx;

		rowIdx = this->getIdxForVertex(startNode);
		colIdx = this->getIdxForVertex(endNode);

		/* Check if vertex nodes are hold by backed container */
		if ((rowIdx < 0) || (colIdx < 0)) {
			cout << "Vertex instance not hold by backed container !!! start="
					<< startNode->name << " | end=" << endNode->name << endl
					<< flush;
		} else {
			matrix[rowIdx][colIdx] = weight;
		}
	}

	void Graph::clearEdges() {
		for (int i = 0; i < maxSize; i++) {
			for (int j = 0; j < maxSize; j++) {
				matrix[i][j] = 0;
			}
		}
	}

	void Graph::clear() {
		clearEdges();
		for (auto it = nodes.begin(); it != nodes.end(); it++) {
			delete (*it);
		}
		nodes.clear();
	}

	void Graph::printDepthFirst(const Vertex* start) const {
		/* start is null */
		if (start == nullptr) {
			cout << "start vertex is null !!! Cannot print graph on null vertex"
					<< endl << flush;
			return;
		}
		/* start not part of graph */
		else if (getIdxForVertex(start) == -1) {
			cout << "given start is not part of this graph !!!" << endl
					<< flush;
			return;
		}

		/* prepare visited stack */
		vector<Vertex*> visited;

		/* start recursion */
		deepTraverse(nodes[getIdxForVertex(start)], &visited);
	}

	void Graph::printBreadthFirst(const Vertex* start) const {
		vector<Vertex&> visited;

	}

	////////////////////////////////////////////////////////////
	// friend methods                                         //
	////////////////////////////////////////////////////////////
	ostream& operator<<(ostream& os, const Graph& graph) {
		int i = 0;
		os << "print graph:" << endl;
		for (auto it = graph.nodes.begin(); it != graph.nodes.end(); it++) {
			os << "node: " << (*it)->name << endl;
			for (int j = 0; j < graph.nodes.size(); ++j) {
				if (graph.matrix[i][j] != 0) {
					os << "     related node: " << (*it) << "("
							<< graph.matrix[i][j] << ")" << endl;
				}
			}
			i++;
		}

		return os;
	}

































		/**
		 * This class represents the set edge between two vertex nodes.
		 * The edge keeps references to the vertex nodes for later usage.
		 */
		class Edge {

			public:
				////////////////////////////////////////////////////////////
				// Public members                                         //
				////////////////////////////////////////////////////////////
				/**
				 * The weight of the edge.
				 */
				const double weight;
				/**
				 * The related row vertex, which is the parent vertex.
				 */
				const Vertex *rowVertex;
				/**
				 * The related col vertex, which is the related child vertex.
				 */
				const Vertex *colVertex;

				////////////////////////////////////////////////////////////
				// Constructor and Destructor                             //
				////////////////////////////////////////////////////////////
				/**
				 * @param
				 * 		weight: the weight to be set on the node
				 * @param
				 * 		rowVertex: the parent vertex
				 * @param
				 * 		colVertex: the related child vertex
				 */
				inline Edge(double weight, Vertex *rowVertex, Vertex *colVertex) :
						weight(weight), rowVertex(rowVertex), colVertex(
								colVertex) {
				}

				inline Edge() :
						weight(-1), rowVertex(nullptr), colVertex(nullptr) {
				}
		};